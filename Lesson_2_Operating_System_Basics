#Overview

Typically an Operating System(OS) will be installed on at least one hard drive connected to the motherboard of the computer. From this hard drive the Operating system will interface and manage other connected devices through the use of a kernel. You can also install one OS on multiple hard drives which allows it to spread itself across multiple hard drives evenly with a copy of all its information also spread out evenly across the hard drives. Thanks to this you can ensure that if a hard drive goes bad or is taken away you will not lose anything. This kind of setup is called a RAID (Redundant Array of Independent Disks) with there being multiple versions. The main difference between each version of RAID is how many hard drives you can lose before you lose some information/data. An example would be  RAID 0 which is one OS evenly spread across two or more hard drives but with no copy also put on the hard drives. while RAID 1 ensures a copy of the data is placed on a hard drive ensuring if one hard drive completely fails no data is lost). Lastly there are Six core Parts to an operating system comprised of a kernel, Program execution, Modes, Memory management, input/output  or read/write managment, a network management center and lastly a user interface.

#The Kernel 

The kernel is the part of the OS that is responsible for the control, monitoring and manipulation of the connected devices. First the part of the kernel that is responsible for directly interacting with these devices is called firmware which is responsible for knowing what is connected, what kind of information connected devices provides, what kind of input they receive and how to control them. Next the second/last part of the kernel are the device drivers which are responsible for being the middle man between the different programs/software and the connected hardware. There is a device driver for each piece of hardware and it dictates the nuances all software/programs must use to communicate with its associated hardware, without said device driver you are unlikely to be able to interact with its hardware. Through the use of the kernel an OS ensures that resources are properly utilized so that actions demanded of different pieces of hardware do not give said hardware too many tasks at one time, asks for something unrelated to the service said hardware provides or interrupts requests for actions that will waste more time/resources than what is allowed. In summary the kernel is the middle man that tries to ensure software/programs can request that pieces of hardware do things and hardware can request/tell the software/programs things without things being lost in translation since they may not communicate normally in a compatible manner.

#Program Execution

A hard drive is used to store information, this information is normally grouped/connected to its related parts, one grouping/connection is called a file. In other words a file is a collection of information stored on the hard drive, if the file contains instructions/requests for actions it is called a program or a piece of software. When a file makes a request this request will first claim a portion of the CPU's processing power for itself, which is part of the reason why this action that the request started is called a process. Next the program that contains the requested actions will be stored in RAM so that when the operations that are started by its request are performed if it modifies space on the hard drive there will be no problem if the space it was originally stored at on the hard drive is deleted/corrupted (otherwise if that happened it could cause problems/errors and would result in the action not being completed). Now the program that has been loaded onto RAM will interact with the different device drivers to complete its task whether it is to just open another file on the hard drive, write some piece of information onto a particular piece of available space on the hard drive, tell a particular piece of hardware to do something, and etc.... The list of possible actions goes on but the thing to keep in mind is that the operating system will manage the number of processes/requested actions that are currently running in memory (RAM) so that it makes efficient use of its resources and doesn't use more than what is available. 

#Modes of Operation

In order to control what actions everything that is apart of a computer can perform including the people/humans on it power is separated into different categories called modes. Each mode has certain requirements in order to qualify to run in it but once apart of it you are allowed to do the associated actions, for example kernel mode which allows for direct interaction with the different pieces of hardware. There are two main modes of operation though each mode has subcategories, the first is kernel mode which is typically only given to things that are necessary for making the computer work and will normally be setup so that only a select few can tell the hardware to perform actions but almost everyone in that mode can send/receive information from the hardware.  The second is user mode which will typically be divided up so that a privileged user(administrator) can make configuration changes while a normal user can only change/create/view things they have made and things the privileged user gave them access to. Using this method has allowed for security to be implemented on these computers so that they can be used for things like say just inputting and accepting information about things into files (powerpoints, excel documents, video games and etc....) and websites (facebook, google, myspace and etc...). While you can create things inside of these files/programs/software thanks to the setup of modes normal people cannot change the core capabilities of these different things. 

#Memory Management

Resources are limited no matter what area you are looking at but computers strictly regulate its resources so that when something isn't used it is freed up and also so that it can keep track of everything everyone/thing is making use of. The most common things managed though is the amount of available space (memory) on the hard drive and also the amount of available space (memory) on the RAM. Normally the OS keeps track of what is in use, what has been marked as unwanted (deleted) by the user/programs and what space is available. When space is needed for something the OS will then make use of the unwanted/deleted space and the available space. That is how people normally recover information by looking at the space that was used to store a file/program and was deleted by the user which removes the marking that says it is in use but was not actually given to another program/file. Due to this the file/information/program will still exist in memory but will simply not be shown by the OS which uses a system called a file system to manage showing how much memory is available, how much memory is already being used and who/what is it being used by.  Just remember that typically the available memory a computer shows you includes the space taken up by a file that you deleted but was really just marked so that it would be reused/recycled but not before explicitly necessary since it would be a waste of time/actions. 

#Management of Data Input/Output 

Most pieces of hardware that are connected to a computers motherboard tend to be comprised of three parts, a Standard Input, Standard Output and a Standard Error. Standard Input is the method/format that must be used/followed in order to send information/data to the associated piece of hardware. The information received by the hardware will change either the what is being outputted, how things will be outputted or where the output will be sent. It will be comprised of things like the amount of voltage a certain piece of hardware should use, what color should be streamed at a certain point during a VGA connection or the delay between turning something on and off.  Standard Output is the format the responses of connected hardware takes, for example the speed a fan will turn at or what colors are outputted and in what order (Video Graphics Array (VGA) which is one of the methods computers use to connect to a screen and show something doesn't have memory so when it is displaying an image the computer is sending a continuous stream of basically colors and in the order it wants them shown in so to change the image it must change the order the colors are sent in and what colors are sent). Lastly Standard Error is what form messages must take when notifying whatever is connected that this piece of hardware failed to receive information (Standard Input) or failed at changing/sending information (Standard Output). Standard Error is used to verify that the entire process the hardware goes through is working, the process is first a piece of hardware is connected to a motherboard and starts taking/requesting power from the motherboards connected power supply. Next the motherboard starts sending the electricity (power) to that piece of hardware which is how the read only memory chip that has the BIOS installed on it knows what is connected because each connected device will either be taking in power or sending power. Now that power is cycling through if the connected hardware is designed to take a reading it will send the results of the reading to the motherboard using STDOUT (standard output) otherwise it will wait until it receives STDIN (standard input) that will give it information or tell it to change a value. Once the hardware receives STDIN it will respond in a preconfigured manner which could be something as simple as change a field that decides the state of a light from 0 to 1 which would turn it on and vice versa.  This process while seemingly simple becomes increasingly complex thanks to the numerous moving parts involved each doing their own simple action which helps complete the purpose of the machine this piece of hardware is connected to. Lastly since there is a limit to how much input can be received and output can be given the Operating System is responsible for making sure that programs can get access to those resources while ensuring that the more important/higher priority a program is the quicker it will get access to said resources if they are already being utilized by others.

#Networking

In order to communicate to other machines three things are needed, 1) an interface to connect the two of them (Ethernet cables, fiber optic, serial and etc ...), 2) an address and 3) a protocol to handle the crafting, sending and receiving of information. The interface normally used is called a Network Interface Card (NIC) which is built with a port capable of having an Ethernet cable plugged into it. Next typically two addresses will be used an Internet Protocol (IP) address and an Ethernet address, with the Ethernet addresses being built into the NIC by default. In order to obtain an IP address though it must be either 1) assigned manually or 2) obtained through a request to a nearby connected device. Either way the IP address must be a part of the range of allowed addresses determined by the network its connected to in order for the address to be able to communicate with others. Lastly thanks to the Internet Engineering Task Force the Internet Protocol has become the standard most machines use to communicate and that is why normally Operating systems will have them built into themselves already. Currently Internet Protocol Version 4 is mainly used with Internet Protocol version 6 also being viable since both protocols are compatible with each other since they mainly handle the transfer of information using the same method. Of crafting a packet with the address and handling information put into the front of the packet, while the information 
being sent is stored in the center of the packet. This whole process tends to work like the current mailing system only instead of street addresses, peoples names and a letter we have IP/MAC address, port numbers and protocol types replacing the street addresses/peoples names, with the letter being replaced with the information being sent. There is more to this process than what is just stated here but this is a quick/simple representation of what happens on the hosts side.

#User Interface

The Last part of an Operating System is a interface, screen, prompt and etc... that will be used to receive and show  information to the human that is making use of the machine known as a Laptop/Desktop. It typically comes in one of two forms with the first being a graphical user interface in which the primary method of interaction will be through clicking/moving a mouse and an actual image being shown to represent what is happening in the computer. Command line interface is the other form primarily defined by the fact that it will typically only accept words typed into a keyboard as input and will only respond with words printed to a screen (also some beeps/sounds if a speaker is attached to the motherboard). Interfaces change but the core parts of either being word based (Command line interface) or image based (graphical user interface) stay the same just be comfortable with both since they are both pretty common.

#Conclusion

Now that you know the basic physical structure of a computer and the basic logical structure of an Operating System you have a better grasp on the kind of technology we will be analyzing in future posts.
